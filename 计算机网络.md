
### 运输层的两个重要协议
TCP/IP的运输层有两个不同的协议：
(1) 用户数据报协议 UDP (User Datagram Protocol)
(2) 传输控制协议 TCP (Transmission Control Protocol)

### 局域网标准化工作是由 来制定的。
局域网（LAN）的结构主要有三种类型：以太网（Ethernet）、令牌环（Token Ring）、令牌总线(Token Bus)以及作为这三种网的骨干网光纤分布数据接口（FDDI）。它们所遵循的都是IEEE（美国电子电气工程师协会）制定的以802开头的标准。

### 每层协议
![](http://s3.51cto.com/wyfs02/M02/31/76/wKioL1OqcfnB7FEEAAvnF-K6h2I343.jpg)

### 邮件协议
- pop3：从服务器下载到本地；
- SMTP：发送或者中转邮件

### 网络常见基本单位
- 码元：承载信息量的基本信号单位
- 比特：表示信息量的单位
- 数据传输速率：在数值上等于每秒钟传输构成数据代码的二进制比特数
- 误码率：是指二进制码元在数据传输系统中被传错的概率。

### 三次握手四次回收
- CLOSED：初始状态，表示没有任何连接。
<br>
- LISTEN：Server端的某个Socket正在监听来自远方的TCP端口的连接请求。
<br>
- SYN_SENT：发送连接请求后等待确认信息。当客户端Socket进行Connect连接时，会首先发送SYN包，随即进入SYN_SENT状态，然后等待Server端发送三次握手中的第2个包。
<br>
- SYN_RECEIVED：收到一个连接请求后回送确认信息和对等的连接请求，然后等待确认信息。通常是建立TCP连接的三次握手过程中的一个中间状态，表示Server端的Socket接收到来自Client的SYN包，并作出回应。
<br>
- ESTABLISHED：表示连接已经建立，可以进行数据传输。
<br>
- FIN_WAIT_1：主动关闭连接的一方等待对方返回ACK包。若Socket在ESTABLISHED状态下主动关闭连接并向对方发送FIN包（表示己方不再有数据需要发送），则进入FIN_WAIT_1状态，等待对方返回ACK包，此后还能读取数据，但不能发送数据。在正常情况下，无论对方处于何种状态，都应该马上返回ACK包，所以FIN_WAIT_1状态一般很难见到。
<br>
- FIN_WAIT_2：主动关闭连接的一方收到对方返回的ACK包后，等待对方发送FIN包。处于FIN_WAIT_1状态下的Socket收到了对方返回的ACK包后，便进入FIN_WAIT_2状态。由于FIN_WAIT_2状态下的Socket需要等待对方发送的FIN包，所有常常可以看到。若在FIN_WAIT_1状态下收到对方发送的同时带有FIN和ACK的包时，则直接进入TIME_WAIT状态，无须经过FIN_WAIT_2状态。
<br>
- TIME_WAIT：主动关闭连接的一方收到对方发送的FIN包后返回ACK包（表示对方也不再有数据需要发送，此后不能再读取或发送数据），然后等待足够长的时间（2MSL）以确保对方接收到ACK包（考虑到丢失ACK包的可能和迷路重复数据包的影响），最后回到CLOSED状态，释放网络资源。
<br>
- CLOSE_WAIT：表示被动关闭连接的一方在等待关闭连接。当收到对方发送的FIN包后（表示对方不再有数据需要发送），相应的返回ACK包，然后进入CLOSE_WAIT状态。在该状态下，若己方还有数据未发送，则可以继续向对方进行发送，但不能再读取数据，直到数据发送完毕。
<br>
- LAST_ACK：被动关闭连接的一方在CLOSE_WAIT状态下完成数据的发送后便可向对方发送FIN包（表示己方不再有数据需要发送），然后等待对方返回ACK包。收到ACK包后便回到CLOSED状态，释放网络资源。
CLOSING：比较罕见的例外状态。正常情况下，发送FIN包后应该先收到（或同时收到）对方的ACK包，再收到对方的FIN包，而CLOSING状态表示发送FIN包后并没有收到对方的ACK包，却已收到了对方的FIN包。有两种情况可能导致这种状态：其一，如果双方几乎在同时关闭连接，那么就可能出现双方同时发送FIN包的情况；其二，如果ACK包丢失而对方的FIN包很快发出，也会出现FIN先于ACK到达。

### OSI层次关系
每一层为下一层提供服务，并为上一层的数据进行封装
注：在数据链路层，会加入尾部
![](https://uploadfiles.nowcoder.com/images/20190315/4139412_1552640698562_1DF25FEC7444AE44A2BDA7C6A0C32719)

### 重传机制

FCS，帧校验（Frame Check Sequence）
发现出错的帧后，通过 **重传** ，再次发送该帧，从而确保能够正确达到对方。


### HTTP头部

![](http://uploadfiles.nowcoder.com/images/20151021/141075_1445359289811_17BB9E04A264B76E04E1995B6166AD2A)

### 子网掩码的算法
某主机的IP地址202.117.131.12/20,其子网掩码是

11111111   11111111  11110000   00000000
一共是32位，前20位是全1，后16位是全0. 这就是202.117.131.12/20中的12/20意义。


### Socket连接流程

首先，服务器端启动进程，调用Socket创建一个基于TCP协议的流套接字描述符。

其次，服务进程调用bind命名套接字，将套接字描述符绑定到本地地址和本地端口上。
再次，服务器端调用listen，开始侦听客户端的Socket连接请求。
接下来阻塞，直到收到了客户端的connect请求，调用accept进行相应。
因此，不阻塞bind和listen
![](https://uploadfiles.nowcoder.com/images/20160811/825067_1470885419407_63C85D8FEA3A65F4A0888E30607C53A7)

### HTTP状态码

1XX（信息状态码）接受请求正在处理
2XX（成功状态码） 请求正常处理完毕
3XX（重定向状态码） 需要附加操作已完成请求
4XX（客户端错误状态码） 服务器无法处理请求
5XX（服务器错误状态码） 服务器处理请求出错

### TCP报文的首部与IP数据报的首部的字节数
TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。
一个IP数据报首部的长度也是20字节，再加上60字节的数据，一个IP数据报的总长度为100字节，可以知道数据占60%。

![](https://uploadfiles.nowcoder.com/images/20190812/300975041_1565609761824_BA4533C4CEF208B165BB5B7305AAE554)


### 各层数据传输格式

- 应用层，报文
- 运输层，报文段
- 网络层，数据报
- 数据链路层，帧

常用的信息格式包括帧、数据包、数据报、段、消息、元素的数据单元。
物理层：传输比特流bit
数据链路层：传输数据帧frame
网络层：传输数据包Packet或者数据报datagram
传输层：传输段segment
应用层：传输消息message
